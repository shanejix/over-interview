/**
 * 
 * 基于构造函数创建自定义类（constructor）
 * 
 *      1.普通函数执行+new操作符
 * 
 *      2.自定定义类，函数名首字母大写
 * 
 * 构造函数设计模式执行，主要用于组件、类库、插件、框架等的封装
 * 
 * 普通函数的执行流程：
 * 
 * 1.形成一个私有作用域
 * 
 * 2.形参赋值
 * 
 * 3.变量提升
 * 
 * 4.代码执行
 * 
 * 5.栈内存释放
 * 
 * 构造函数的执行流程：
 * 
 * 相对于普通函数多了一个new操作
 * 
 * new的原理：
 * 
 * 1.在构造函数内部开辟一块堆内存
 * 
 *  let obj = {};
 * 
 * 2.改变obj的原型指向
 * 
 *  obj.__proto__ = Fn.prototype
 * 
 * 3.绑定this
 * 
 * obj.bind(this);
 * 
 * 4.返回
 * 
 * 
 */

function Fn() {
    var n = 10;
    this.m = n;
    // return;
    //return是的一个基本值，返回的结果依然是类的实例，没有受到影响
    //如果返回的是引用值，则会把默认返回的实例覆盖，此时接收到的结果就不在是当前类的实例了
}

var f = new Fn();//=>new Fn;  如果Fn不需要传递实参，可以省略小括号


/**
 * 
 * 检测某一个实例是否隶属于这个类
 * instanceof
 * 
 * 检测当前对象是否存在某个属性（不管当前这个属性是对象的私有属性还是公有属性)
 * in
 * 
 * 检测当前属性是否为对象的私有属性（
 * hasOwnProperty
 * 
 */

